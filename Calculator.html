<!DOCTYPE html>
<html>
<head>
	<title>Calculator</title>
	<style>
		td {
			vertical-align: top;
		}
		
		* {
			//spadding: 0;
			//smargin: 0;
		}
		table, td {
			border: 2px solid black;
			border-collapse: collapse;
		}
		
		body {
			//color: white;
			font-size: 1.2em;
			font-weight: bold;
		}
		
		td {
			//background-color: red;
			//background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);
			background: linear-gradient(to right, red, orange, yellow, lime, violet);
			//background: linear-gradient(to right, lime, yellow, lime);
		}
		
		.prettyprinthtml {
			text-align: center;
		}
		
		.prettyprinttext {
			text-decoration: underline;
			text-color: red;
		}
	</style>
</head>
<body>

	<table>
		<tr>
			<td>

				<textarea id="input" rows="20" cols="50">
3
2 ^ 8
(12 % 7) * (3 + 2)
19 / -9

hoursPerDay = 24
minutesPerHour = 60
minutesPerDay = minutesPerHour * hoursPerDay
minutesPerDay
minutesPerDay * 60

toDegrees(radians) = radians * 180 / pi
toDegrees(2 * pi)

cylinderVolume(r, h) = pi * r ^ 2 * h
cylinderVolume(2, 4)

PrettyPrint(1,2)
				</textarea>
			<td>
				<button id="calculate">Calculate</button><br>
				<button id="prettyprint">PrettyPrint</button><br>
				<button id="clear">Clear</button><br>
				<button id="prettyprintselection">PrettyPrint Selection</button><br>
				<button id="prettyprinthtml">PrettyPrintHTML</button><br>
				<button id="tokentable">TokenTable</button><br>
				<button id="parsestepselection">ParseStepSelection</button><br>
			<td>
				<pre id="output" style="min-width:100px; border: 1px solid black"></pre>
		<tr>
	</table>


<script>
	function getArgs(func) {
		var s;
		s = func.toString();
		s = s.substring(10, s.indexOf(")"));
		s = s.replace(/ /g, "");
		return s.split(",");
	}
	
	/*
		function(id, leftBindingPower, rightBindingPower, leftDenotation) {
			
			eval("console.log(\"infix:\", id, leftBindingPower, rightBindingPower, leftDenotation, getArgs(parser).join('a'));")
			oldinfix(id, leftBindingPower, rightBindingPower, leftDenotation);
		}
	*/
	
	function toSource(func) {
		var src = func.toSource();
		//console.log(src);
		return src.substring(src.indexOf("{")+1, src.length - 2);
	}
	
	function hookLog(obj, oldFunc, funcname) {
		var tmp;
		tmp += "a = function (obj, oldFunc, funcname)";
		tmp += "{";
			//tmp += "console.log(\"oldFunc:\", oldFunc, \"parser:\", obj);";
		
			var args = getArgs(oldFunc);
			tmp += "return function (" + args.join(",") + ")";
			tmp += "{";
				tmp += toSource(function() {
					var a = [funcname + ">"];
					for (var i=0; i<args.length; i++) {
						a.push(args[i], eval(args[i]));
					}
					console.log.apply(null, a);
					//oldFunc.apply(obj, args);
				});
				tmp += "return oldFunc.bind(obj)(" + args.join(",") + ");";
				
			tmp += "}";
		
		tmp += "}";
		var newFunc = eval(tmp)(obj, oldFunc, funcname);
		// FireBug: parser.expression.oldFunc.toSource()
		// Idea: s/arguments.keys()/arguments.values() and just print it, for debugging the actual values directly in source
		newFunc.oldFunc = oldFunc;
		return newFunc;
	}
	
	var calculate = function (input) {
		var tokens = lex(input);
		//var parseTree = parse(tokens);
		parser = new Parser(tokens);
		
		parser.infix = hookLog(parser, parser.infix, "infix");
		parser.expression = hookLog(parser, parser.expression, "expression");

		parser.init();

		comma = parser.symbols["="];
		comma.infixCallback = hookLog(comma, comma.infixCallback, "Equal sign");
		
		parser.parse();
		var output = evaluate(parser.parseTree);
		return output;
	};

	function clear() {
		document.getElementById("output").innerHTML = "";
	}
	function print(msg) {
		document.getElementById("output").innerHTML += msg + "\n";
	}
	
	function getInput() {
		return document.getElementById("input").value;
	}
	function getSelectedInput() {
		var textarea = document.getElementById("input");
		var s = textarea.selectionStart;
		var e = textarea.selectionEnd;
		return textarea.value.substring(s,e);
	}
	
	document.getElementById("calculate").onclick = function () {
		output = calculate(getInput());
		print("\nStatement evaluations: \n" + output);
	};
	document.getElementById("clear").onclick = function () {
		clear()
	};
	document.getElementById("prettyprint").onclick = function () {
		output = calculate(getInput());
		
		var tokens = lex(getInput());
		parser = new Parser(tokens);
		parser.init();
		parser.parse();
		
		PrettyPrint(parser.parseTree, 0);
	};
	document.getElementById("prettyprintselection").onclick = function () {
		var input = getSelectedInput();
		print("Selection: <div class=selection>" + input + "</div>");
		
		output = calculate(input);
		
		var tokens = lex(input);
		parser = new Parser(tokens);
		parser.init();
		parser.parse();
		PrettyPrint(parser.parseTree, 0);
	};
	document.getElementById("prettyprinthtml").onclick = function () {
		var input = getInput();
		//print("Selection: <div class=selection>" + input + "</div>");
		
		//output = calculate(input);
		
		var tokens = lex(input);
		parser = new Parser(tokens);
		parser.init();
		parser.parse();
		print(PrettyPrintHTML(parser.parseTree, 0));
	};
	document.getElementById("tokentable").onclick = function () {
		var input = getInput();
		//print("Selection: <div class=selection>" + input + "</div>");
		
		//output = calculate(input);
		
		var tokens = lex(input);
		parser = new Parser(tokens);
		parser.init();
		//parser.parse();
		//print(PrettyPrintHTML(parser.parseTree, 0));
		
		var html = new HTML().table().tr().td("type").td("value").td("lbp").td("inf<br>rbp").td("pre<br>rbp");
		for (i in tokens) {
			t = tokens[i];
			sym = parser.symbols[t.type];
			html.tr();
			html.td(t.type);
			html.td(t.value || "");
			html.td(sym.leftBindingPower);
			if (sym.closure_infix)
				html.td(sym.closure_infix.rightBindingPower);
			else
				html.td("");
			if (sym.closure_prefix)
				html.td(sym.closure_prefix.rightBindingPower);
			else
				html.td("");
		}
		print(html.source);
	};
	document.getElementById("parsestepselection").onclick = function () {
		var input = getSelectedInput();
		print("Selection: <div class=selection>" + input + "</div>");
		//print("Selection: <div class=selection>" + input + "</div>");
		
		//output = calculate(input);
		
		var tokens = lex(input);
		parser = new Parser(tokens);
		parser.init();
		//parser.parse();
		//print(PrettyPrintHTML(parser.parseTree, 0));
		
		print("Tokens: " + tokens.length)
	};
	
	
</script>

<script src="lexer.js"></script>
<script src="parser.js"></script>
<script src="evaluator.js"></script>
<script src="PrettyPrintHTML.js"></script>
<script src="HTML.js"></script>

<!--
<button onclick="context.clearRect(0, 0, canvas.width, canvas.height)">Clear Canvas</button>
<button onclick="paintAST()">Paint AST</button>
<canvas id="myCanvas" width="2000" height="2000"></canvas>
<script>
var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');

function line(from_left, from_top, to_left, to_top) {
	context.beginPath();
	context.moveTo(from_left, from_top);
	context.lineTo(to_left, to_top);
	context.stroke();
}

function text(text, pos_left, pos_top) {
	console.log(arguments)
	context.font = '20pt Calibri';
	context.fillStyle = 'blue';
	context.fillText(text, pos_left, pos_top);
	pos_top += 50;
}

var pos_left, pos_top;
function PrettyPaint(node, depth)
{	
	switch (node.type) {
		case "call_": {
			print("node.type=" + node.type + " node.name=" + node.name);
			for (var i = 0; i < node.args.length; i++) {
				PrettyPaint(node.args[i], depth + 1);
			}
			break;
		}
		case "number_": {
			print("node.type=" + node.type + " node.value=" + node.value);
			break;
		}
		
		default:
			nonewline = function(msg) { return msg.replace(/\r\n/g, " ").replace(/\n/g, " "); }
			tmp = "";
			for (key in node) {
				if (key == "args" || key == "pos_left" || key == "right" || key == "symbol") // will be printed separately
					continue;
				tmp += "node." + key + "=" + node[key] + " ";
			}
			text(nonewline(tmp), pos_left, pos_top);
			if (typeof node.symbol != "undefined") {
				text("node.symbol:", pos_left, pos_top);
				
				tmp = "";
				for (key in node.symbol) {
					if (key == "args" || key == "pos_left" || key == "right" || key == "symbol") // will be printed separately
						continue;
					tmp += "node." + key + "=" + node[key] + " ";
				}
				text(nonewline(tmp), pos_left, pos_top);
				
			}
			if (typeof node.pos_left != "undefined") {
				text("node.pos_left:", pos_left, pos_top);
				PrettyPaint(node.pos_left, depth + 1, pos_left, pos_top);
					pos_left += 50;
					pos_top += 50;
			}
			if (typeof node.right != "undefined") {
				text("node.right:", pos_left, pos_top);
				PrettyPaint(node.right, depth + 1, pos_left, pos_top);
					pos_left += 50;
					pos_top += 50;
			}
			if (typeof node.args != "undefined") {
				text("node.args:", pos_left, pos_top);
				for (var i = 0; i < node.args.length; i++) {
					PrettyPaint(node.args[i], depth + 1, pos_left, pos_top);
					pos_left += 50;
					pos_top += 50;
				}
			}
			if (typeof node.statements != "undefined") {
				text("node.statements:", pos_left, pos_top);
				for (var i = 0; i < node.statements.length; i++) {
					text("node.statement["+ i +"]:", pos_left, pos_top);
					PrettyPaint(node.statements[i], depth + 1, pos_left, pos_top);
					//pos_left += 50;
					pos_top += 50;
				}
			}
			break;
	}
}

function paintAST() {
		var tokens = lex(getInput());
		parser = new Parser(tokens);
		parser.init();
		parser.parse();
		pos_left = 50;
		pos_top = 50;
		PrettyPaint(parser.parseTree, 0);
}

text("100 10", 100, 10);
text("10 100", 10, 100);
line(100, 10, 10, 100);
</script>
-->

	</body>
</html>
